(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{570:function(a,s,t){"use strict";t.r(s);var _=t(2),e=Object(_.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"账户密码存储方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#账户密码存储方案"}},[a._v("#")]),a._v(" 账户密码存储方案")]),a._v(" "),s("h2",{attrs:{id:"安全的存储用户密码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安全的存储用户密码"}},[a._v("#")]),a._v(" 安全的存储用户密码")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/luokuning/blogs/issues/4",target:"_blank",rel:"noopener noreferrer"}},[a._v("yuanwen"),s("OutboundLink")],1)]),a._v(" "),s("p",[a._v("在我走上编程这条路之前，有个问题困扰了我很久: 为什么每次忘记某个账号的登录密码并且点击“忘记密码”试图找回原密码的时候，都永远只会让我重新填写一个新密码，而不是告诉我原来的密码是什么？很多时候我只想知道之前的密码，并不想再想出一个新的密码，为什么就是不告诉我？")]),a._v(" "),s("p",[a._v("直到正式开始学习编程一段时间后，突然想起这个问题才发现，原来这个问题我还是没搞明白。为了解决当初跟我有同样困惑的同学，今天我们就来仔细讨论一下这个问题。")]),a._v(" "),s("h3",{attrs:{id:"直接存储明文密码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#直接存储明文密码"}},[a._v("#")]),a._v(" 直接存储明文密码")]),a._v(" "),s("p",[a._v("假如某个用户在你的网站上注册了一个账号 "),s("code",[a._v("lk@gmail.com")]),a._v("，密码为 "),s("code",[a._v("abc654321")]),a._v("，")]),a._v(" "),s("p",[a._v("可能有些同学会觉得存储密码最直接的方式可以采用类似这样的表结构 :")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("username")]),a._v(" "),s("th",[a._v("password")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[s("a",{attrs:{href:"mailto:lk@gmail.com"}},[a._v("lk@gmail.com")])]),a._v(" "),s("td",[a._v("abc654321")])])])]),a._v(" "),s("p",[a._v("这种方法简单直接，而且完全可以满足用户想找回原密码的需求。但是，如果某个黑客获得了你数据库的访问权限，那么他就能知道每个用户对应的密码明文。很多用户在多个网站上注册的账号用的都是同样的邮箱和密码，这样相当于黑客轻易就知道了这个用户多个网站的的信息。所以基本上没有谁会采用这种方式存储密码。")]),a._v(" "),s("h3",{attrs:{id:"存储密码的哈希值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存储密码的哈希值"}},[a._v("#")]),a._v(" 存储密码的哈希值")]),a._v(" "),s("p",[a._v("哈希算法是个好东西，由于它不可逆的特性，我们可以存储用户密码的哈希值，类似这样:")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("username")]),a._v(" "),s("th",[a._v("password")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[s("a",{attrs:{href:"mailto:lk@gmail.com"}},[a._v("lk@gmail.com")])]),a._v(" "),s("td",[a._v("5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8")])])])]),a._v(" "),s("p",[a._v("登录验证的时候比较密码的哈希值: "),s("code",[a._v("return sha1(password) == user[sha1_password]")]),a._v("(更好的建议是使用 "),s("code",[a._v("sha256")]),a._v(")。")]),a._v(" "),s("p",[a._v("可以看到这个方法比直接存储明文密码要更安全，黑客无法直接知道原始密码是什么，因为无法通过哈希值反向计算出原始密码。但是，想要知道原始密码并不需要可逆的运算，黑客可以不断的计算某个值的哈希值并且与目的哈希值比较，如果相同，那么表示这个值就是原始密码。")]),a._v(" "),s("p",[a._v("可能你会觉得这么多密码怎么可能计算得过来，但是要知道很多人的密码都是很简短的一些有规律的数字和英文单词组成的，而且很多哈希函数比如 "),s("code",[a._v("sha1")]),a._v(" 计算速度相当快，加之 cpu 的速度越来越快，现在普通的电脑可以一秒完成上亿次计算。(前几年可能还有人用彩虹表这种攻击方式，就是事先计算好一大堆数据的散列，然后循环比较，但是现在的 cpu 计算速度已经比过去翻了很多番，已经很少有人用这种方式了)。")]),a._v(" "),s("p",[a._v("而且需要注意的一点是，这个方法是同时在破解你存储的所有用户密码，所以当你数据库中存储的用户越多，黑客就越容易匹配到冲突的哈希值。")]),a._v(" "),s("p",[a._v("2012 年的时候 LinkedIn 就被泄露了一大批用户密码的 "),s("code",[a._v("sha1")]),a._v(" 值，其中大多数密码都可以被轻易破解。")]),a._v(" "),s("p",[a._v("所以只存储用户密码的简单哈希值还是不够安全。")]),a._v(" "),s("h3",{attrs:{id:"存储密码的加盐-固定-哈希"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存储密码的加盐-固定-哈希"}},[a._v("#")]),a._v(" 存储密码的加盐(固定)哈希")]),a._v(" "),s("p",[a._v("存储的密码值类似这样:")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("username")]),a._v(" "),s("th",[a._v("password")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[s("a",{attrs:{href:"mailto:lk@gmail.com"}},[a._v("lk@gmail.com")])]),a._v(" "),s("td",[a._v('sha1("salt123456789" + password_1)')])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"mailto:john@163.com"}},[a._v("john@163.com")])]),a._v(" "),s("td",[a._v('sha1("salt123456789" + password_2)')])])])]),a._v(" "),s("p",[a._v("注意上面的 "),s("code",[a._v('sha1("salt123456789" + password_1)')]),a._v(" 是表示算法，表中 "),s("code",[a._v("password")]),a._v(" 实际存储的是算法的值。")]),a._v(" "),s("p",[a._v("由于在计算密码哈希值的时候使用的是加盐算法(这个“盐”是固定的，很长的一段无序字符串), 所以黑客已经没办法使用彩虹表进行攻击了。")]),a._v(" "),s("p",[a._v("但是假如黑客攻破了你的数据库，那么很可能他也能知道你加的盐是什么(永远不要相信你存储的数据是安全的)，所以这时候其实跟普通哈希无异。而且就算黑客无法知道盐是什么，他还是能用破解普通哈希值一样的方法来破解加盐哈希，只不过要多猜一个“盐”值。")]),a._v(" "),s("p",[a._v("可以看出固定加盐哈希还是不够安全。")]),a._v(" "),s("h3",{attrs:{id:"存储密码的随机加盐哈希"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存储密码的随机加盐哈希"}},[a._v("#")]),a._v(" 存储密码的随机加盐哈希")]),a._v(" "),s("p",[a._v("由固定加盐哈希衍生出来的一种更为安全的办法就是，为每一个密码都分配一个单独的盐，所以存储的结构类似这样：")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("username")]),a._v(" "),s("th",[a._v("salt")]),a._v(" "),s("th",[a._v("password")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[s("a",{attrs:{href:"mailto:lk@gmail.com"}},[a._v("lk@gmail.com")])]),a._v(" "),s("td",[a._v("2dc7fcc...")]),a._v(" "),s("td",[a._v('sha1("2dc7fcc..." + password_1)')])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"mailto:john@163.com"}},[a._v("john@163.com")])]),a._v(" "),s("td",[a._v("afadb2f...")]),a._v(" "),s("td",[a._v('sha1("afadb2f..." + password_2)')])])])]),a._v(" "),s("p",[a._v("随机加盐哈希看起来跟固定加盐哈希差别不大，算法本质上是一样的，只不过是所有的密码不再共享一个固定的盐，而是每个密码都有一个对应的随机盐。这样的好处是黑客破解密码哈希值的时候没办法"),s("strong",[a._v("同时")]),a._v("破解所有用户的密码，因为每个密码对应的盐都不一样，每个密码的破解过程都是独立的。也就是说就算你的库里存了很多用户密码，黑客也不可能通过某个盐循环计算命中多个用户(回顾上面说的普通加盐哈希的破解过程)。")]),a._v(" "),s("p",[a._v("但是归根结底这还是计算量的问题，现在的 cpu 计算速度已经相当快了，而且利用集群和云计算的能力，破解密码会越来越容易。")]),a._v(" "),s("h3",{attrs:{id:"bcrypt-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bcrypt-算法"}},[a._v("#")]),a._v(" bcrypt 算法")]),a._v(" "),s("p",[a._v("普通哈希函数最初的设计目的并不是用来存储密码的，要真正安全地存储密码还是要用到专为这件事设计的哈希算法。这些哈希函数不仅具有唯一、哈希单向不可逆等特性，它们还被设计的“很慢”。")]),a._v(" "),s("p",[a._v("这些函数中一个典型的例子就是 "),s("code",[a._v("bcrypt")]),a._v(" 函数，这个函数计算的伪代码类似这样:")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("hash = bcrypt(plain_password, gensalt(log_rounds))\n")])])]),s("p",[s("code",[a._v("log_rounds")]),a._v(" 参数: 工作因子(work factor)，表示的是这个算法的计算量或者快慢程度。在 "),s("code",[a._v("log_rounds")]),a._v(" 等于 "),s("code",[a._v("12")]),a._v(" 的情况下，这个算法计算一个密码的哈希值可能需要大概 100ms，可能你会觉得很快，但是要知道这是计算一次 "),s("code",[a._v("sha1")]),a._v(" 耗时的 10000 倍。也就是说假如黑客破解一个 "),s("code",[a._v("sha1")]),a._v(" 算法生成的哈希值需要 1 分钟，那么破解 "),s("code",[a._v("bcrypt")]),a._v(" 算法生成的哈希值就大概需要 7 天。")]),a._v(" "),s("p",[a._v("简单来说 "),s("code",[a._v("bcrypt")]),a._v(" 算法就是重复计算内部的加密(散列)函数很多次(类似的算法还有"),s("a",{attrs:{href:"http://en.wikipedia.org/wiki/PBKDF2",target:"_blank",rel:"noopener noreferrer"}},[a._v("PBKDF2"),s("OutboundLink")],1),a._v(")，所以减慢了整体运算速度。如果你想仔细了解一个 "),s("code",[a._v("bcrypt")]),a._v(" 的算法，可以点"),s("a",{attrs:{href:"http://www.openbsd.org/papers/bcrypt-paper.ps",target:"_blank",rel:"noopener noreferrer"}},[a._v("这里"),s("OutboundLink")],1),a._v("。")]),a._v(" "),s("p",[a._v("注意上面的 "),s("code",[a._v("log_rounds")]),a._v(" 这个参数是可配置的，而且值每增加 1 表示的是多 10 倍的计算量(对数式的)。所以如果你觉得 100ms 还是太快了，可以把 "),s("code",[a._v("log_rounds")]),a._v(" 设置为 "),s("code",[a._v("13")]),a._v("，这样一次计算大概耗时 +1s, 哦不是加，就是 1s。突然想念两句诗...")]),a._v(" "),s("p",[a._v("由于这种算法很慢，确实非常慢，所以似乎被淘汰的彩虹表又可以利用起来。但是 "),s("code",[a._v("bcrypt")]),a._v(" 算法是内置就支持“每个密码一个不同的盐”，所以彩虹表是没有用的。说到底，破解密码只是时间的问题，如果时间很长，那么就变成了不可能。")]),a._v(" "),s("h3",{attrs:{id:"mozilla-的密码存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mozilla-的密码存储"}},[a._v("#")]),a._v(" Mozilla 的密码存储")]),a._v(" "),s("p",[a._v("Mozilla 在"),s("a",{attrs:{href:"https://blog.mozilla.org/webdev/2012/06/08/lets-talk-about-password-storage/",target:"_blank",rel:"noopener noreferrer"}},[a._v("这篇文章"),s("OutboundLink")],1),a._v("里介绍了他们使用的密码存储算法: "),s("code",[a._v("password -> bcrypt(HMAC(password, local_salt), gensalt(log_rounds))")]),a._v("，这其实是利用了两个算法的组合。")]),a._v(" "),s("p",[a._v("跟直接使用 "),s("code",[a._v("bcrypt")]),a._v(" 的区别在于，这个算法首先还对密码进行了一次 "),s("code",[a._v("HMAC")]),a._v(" 计算。Mozilla 解释这样的好处是: 用于计算 "),s("code",[a._v("HMAC")]),a._v(" 算法的 "),s("code",[a._v("local_salt")]),a._v(" 是直接存储在服务器而不是数据库中的，所以如果黑客攻破了数据库，他还需要再攻破服务器取得 "),s("code",[a._v("local_salt")]),a._v(" 的值才行。")]),a._v(" "),s("p",[a._v("虽然听起来更可靠，但我还是觉得跟直接计算 "),s("code",[a._v("bcrypt")]),a._v(" 比起来，"),s("code",[a._v("HMAC")]),a._v(" 这一步有点多余。")]),a._v(" "),s("h3",{attrs:{id:"结语"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[a._v("#")]),a._v(" 结语")]),a._v(" "),s("p",[a._v("上面说了这么多，总结起来就是: 如果你想要安全的存储用户的密码，非常重要的一点是选择一个“慢”的密码存储算法，比如 "),s("code",[a._v("bcrypt")]),a._v("。 但是最重要的一点是，最好提示你的用户能够选择复杂一点的密码，类似 16 位以上的无序字母和数字。假如某个密码是 "),s("code",[a._v("123456")]),a._v(" 或者 "),s("code",[a._v("654321")]),a._v("，那么没什么算法能够保证它是安全的，因为黑客总是从最简单最常用的一些密码列表开始匹配。")]),a._v(" "),s("h1",{attrs:{id:"web-前端密码加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#web-前端密码加密"}},[a._v("#")]),a._v(" Web 前端密码加密")]),a._v(" "),s("p",[a._v("关于这个问题我有发言权，因为我最初在开发 "),s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/107839880",target:"_blank",rel:"noopener noreferrer"}},[a._v("Zhihu On VSCode"),s("OutboundLink")],1),a._v(" 时候，就被加密后的 js 代码搞得一头雾水，极大程度上拖慢了我的开发进度。")]),a._v(" "),s("p",[a._v("众所周知，知乎是没有公开的 API 的，然而我却要在一个非浏览器平台上实现知乎的账密登录，二维码登录，微信登录，文章发布，内容浏览等功能，插件的开发，最开始的账密登录的模拟是最为困难的，后来等验证方面功能稳定了，其它功能的开发便变得十分顺畅。")]),a._v(" "),s("p",[a._v("一般我们用账号密码登录一个网站，前端会用 POST 请求发送一个类似于如下格式的 json 文本到服务端：")]),a._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[a._v('"username"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"niudai"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[a._v('"password"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"mypassword"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("那既然是明文传送，是什么保证我们请求的安全性呢？答案是 TLS 层。")]),a._v(" "),s("p",[a._v("也就是说，虽然我们传了个 json 明文，但真正传输的，是经过 TLS 加密后的密文，我们可以认为一般意义上，TLS 是可以保证我们和服务器端传输的安全性的，这安全性主要包括三方面：")]),a._v(" "),s("ol",[s("li",[a._v("机密性。（第三方截获数据无法知道明文是什么）")]),a._v(" "),s("li",[a._v("数据完整性。（第三方篡改数据，会使得数据变得无效）")]),a._v(" "),s("li",[a._v("认证。（交流双方可以确认对方的身份，第三方无法伪装成任何一方进行交流）")])]),a._v(" "),s("p",[a._v("具体实现的技术，主要包含了 Public-Private-Key加密（保证第一个），对称加密（保证第一个），hash 散列函数（保证第二个），CA机构（保证第三个）。")]),a._v(" "),s("p",[a._v("我们以 Github 的登录为例：")]),a._v(" "),s("p",[a._v("登录请求，发送了 Form Data，我们看到的确包含了我们的用户名和密码，也就是说，前端代码在登录方面，无需对登录的数据做任何加密处理，tls 层已经保证了安全性。")]),a._v(" "),s("p",[a._v("所以，我们在非浏览器端，模拟 Github 的登录，十分容易，只需要随便一个语言，用语言的相关 HTTP 库发送和这个一样的请求，我们就能登录成功。")]),a._v(" "),s("p",[a._v("但是奇怪的是，知乎的登录请求却是")]),a._v(" "),s("p",[a._v("一堆密文！")]),a._v(" "),s("p",[a._v("也就是说，虽然我们输入的的确是用户名和密码，但是知乎的前端代码对我们的数据进行了加密，如果搞不明白怎么加密的，就无法模拟知乎登录，而知乎第三方客户端的实现也无从谈起。")]),a._v(" "),s("p",[a._v("为了搞明白具体是怎么加密的，我们必须深入知乎的前端代码")]),a._v(" "),s("p",[a._v("本来的代码是没有排版全部挤在一起的，也就是说，为了搞明白前端如何对我们登录数据加密的，你需要搞明白这些代码都在做什么。")]),a._v(" "),s("p",[a._v("于是我采用了打断点的方式，从点击登录按钮开始，不断地查看个各种变量的值，经过很多细致的研究，最后发现知乎是这样做的：")]),a._v(" "),s("ol",[s("li",[a._v("把用户的手机号和密码，再加上其它相关参数，比如时间戳，组合成一个 object。")]),a._v(" "),s("li",[a._v("对这个 object 进行序列化，进行 Url Encoded，然后和一个 private key 拼在一起，用 sha1 算法算出 digest，然后再拼起来。")]),a._v(" "),s("li",[a._v("再进行加密，加密的过程是一段奇怪的，混淆严重的 js 代码。")])]),a._v(" "),s("p",[a._v("加密的过程，只能把那段 js 代码整个打过来，做加密，具体怎么加密的，很难看懂。")]),a._v(" "),s("p",[a._v("当然了，所有这一切，都发生在前端代码里，那些 key ，也都在前端代码里，然而知乎这么做，让模拟登录变得十分困难，从而阻止了很多潜在的第三方客户端的存在和机器人。")]),a._v(" "),s("p",[a._v("大家有兴趣可以去 Github 上看看知乎模拟登录的项目，几乎全部无效，都无法使用，对于知乎这种闭源的生态，从技术上遏制第三方应用和机器人的存在，这便是知乎前端登录加密的意义。")]),a._v(" "),s("p",[a._v("当然了，知乎这套东西还是没防住我 。")]),a._v(" "),s("p",[a._v("那些说 tls 层不能很好的保证安全性，前端可以增强安全性的，完全胡扯，按你这么说，github 的安全性应该很低了，因为 github 的前端就没加密。")]),a._v(" "),s("p",[a._v("还有，比如爱奇艺的视频解码。")]),a._v(" "),s("p",[a._v("我当时看了一下爱奇艺的视频资源请求，请求来的数据，也是不能直接播放的，但是在爱奇艺的网站里能播放，说明爱奇艺前端代码会先将请求来的视频数据进行解密。")]),a._v(" "),s("p",[a._v("如果这个解密的代码搞得很乱很复杂，就让爱奇艺的视频模拟下载变得更加困难，这符合爱奇艺这种闭源会员制的网站的利益，但是大家有兴趣可以去看一下 youtube 的视频资源请求，请求来的数据是可以直接播放的，这一点和爱奇艺不同。")]),a._v(" "),s("p",[a._v("如果你的生态是开放的，像 Github 这样，把 API 公开，鼓励各种第三方客户端，那前端就没必要加密，如果你是闭源生态，巴不得所有人都从你这个入口进来，那关键部分做一下前端代码的加密混淆，会减少很多第三方应用。")]),a._v(" "),s("p",[a._v("再聊聊后续。")]),a._v(" "),s("p",[a._v("账密登录被我 diable 掉了，取而代之的是知乎二维码登录和微信扫码登录：")]),a._v(" "),s("h1",{attrs:{id:"注册、登录和-token-的安全之道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注册、登录和-token-的安全之道"}},[a._v("#")]),a._v(" 注册、登录和 token 的安全之道")]),a._v(" "),s("p",[a._v("最近想要做一个小项目，由于前后都是一个人，在登录和注册的接口上就被卡住了，因此想登录、注册、口令之间的关系，使用 PHP 实现登录注册模块，和访问口令。")]),a._v(" "),s("p",[a._v("出于安全的考虑，首先定下三项原则：")]),a._v(" "),s("ol",[s("li",[a._v("在传输中，不允许明文传输用户隐私数据；")]),a._v(" "),s("li",[a._v("在本地，不允许明文保存用户隐私数据；")]),a._v(" "),s("li",[a._v("在服务器，不允许明文保存用户隐私数据；")])]),a._v(" "),s("p",[a._v("在网络来说，我们知道不论 POST 请求和 GET 请求都会被抓包，在没有使用 HTTPS 的情况下，抓包我们是防不住的，如果明文传输用户隐私，那后果就不说了。")]),a._v(" "),s("p",[a._v("本地和服务器也是如此，比如 iOS 设备，如果存储在本地，越狱之后通过设备 Finder 之类的功能，也能轻易找到我们存储在本地的用户隐私。")]),a._v(" "),s("blockquote",[s("p",[a._v("使用 Keychain 在本地也有保存，但不在沙盒，暂且忽略。")])]),a._v(" "),s("p",[a._v("上面讲到，用户隐私数据总归可以被拿到的，如何保证被拿到之后不会被用来做坏事？")]),a._v(" "),s("h2",{attrs:{id:"加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加密"}},[a._v("#")]),a._v(" 加密")]),a._v(" "),s("p",[a._v("将用户的隐私数据加密，那么就算被拿到，也无法被拿来使用。在这里呢，我们先不谈加密，而是先纠正一个误区，有些朋友会认为 Base64 可以加密，甚至有 Base64 加密的说法。")]),a._v(" "),s("p",[a._v("Base64 主要不是加密，它主要的用途是把二进制数据序列转化为 ASCII 字符序列，用以数据传输。二进制数据是什么呢？计算机上存储的所有数据，都是二进制数据。")]),a._v(" "),s("p",[a._v("Base64 最常见的应用场景是 URL，因为 URL 只能是特定的一些 ASCII 字符。这时需要用到 Base64 编码，当然这也只是对二进制数据本身的编码，编码后的数据里面可能包含 "),s("code",[a._v("+/=")]),a._v(" 等符号，真正放到 URL 里面时候，还需要URL-Encoding，变成 "),s("code",[a._v("%XX")]),a._v(" 模式，以消除这些符号的歧义。其次就是将图片转为 Base64 的字符串。")]),a._v(" "),s("p",[s("strong",[a._v("因此，Base64 只是一种编码方式，而不是加密方式。")])]),a._v(" "),s("p",[a._v("好了，现在回到我们的主题，先说登录和注册之间的关系，这 3 个模块需要做什么事情呢？")]),a._v(" "),s("ul",[s("li",[a._v("注册：将用户输入的隐私数据，发送给服务器，服务器进行保存；")]),a._v(" "),s("li",[a._v("登录：将用户输入的隐私数据，发送给服务器，服务器进行比对，确认是否有权限登录；")]),a._v(" "),s("li",[a._v("token：确保用户在登录中；")])]),a._v(" "),s("p",[a._v("我们把用户输入的隐私数据再具象一些，比如账号和密码，结合我们上面提到的安全原则，那么分解开来，实际我们要做以下几件事：")]),a._v(" "),s("ul",[s("li",[a._v("服务器-注册接口：接收客户端传来的账号和密码，将其保存在数据库中；")]),a._v(" "),s("li",[a._v("服务器-登录接口：接收客户端传来的账号和密码，与数据库比对，完全命中则登录成功，否则登录失败；\n"),s("ul",[s("li",[a._v("登录成功后，生成或更新 token 和过期时间，保存在数据库， token 返回给客户端；")]),a._v(" "),s("li",[a._v("服务器定期清除 token；")])])]),a._v(" "),s("li",[a._v("客户端-注册模块：向服务器注册接口发送账号和密码；")]),a._v(" "),s("li",[a._v("客户端-登录模块：向服务器登录接口发送账号和密码；\n"),s("ul",[s("li",[a._v("登录成功后，保存 token 到本地；")]),a._v(" "),s("li",[a._v("退出登录后，清除 token；")])])]),a._v(" "),s("li",[a._v("发送的账号和密码需要加密；")]),a._v(" "),s("li",[a._v("数据库中需要保存的是加密后的账号和密码；")]),a._v(" "),s("li",[a._v("请求敏感数据时，将客户端传来的 token 和服务器验证，不通过则提示客户端登录；")])]),a._v(" "),s("p",[a._v("上面逻辑理清楚后，相信对于大家来说并不难实现，以下是服务器注册接口做的事情：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*检查用户名是否存在*/\n$is_exist = $db->check_user_exist($account);\n\nif ($is_exist) {\n    echo return_value(10001, false);\n}\nelse {\n    /*检查用户名是否添加成功*/\n    $result = $db->add_user($account, $password);\n    if ($result) {\n        echo return_value(0, true);\n    }\n    else {\n        echo return_value(20001, false);\n    }\n}\n")])])]),s("p",[a._v("现在是服务器登录接口做的事情：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*是否命中用户名和密码*/\n$should_login = $db->should_login($account, $password);\n\nif ($should_login) {\n    /*更新 token*/\n    $token = $db->insert_token($account);\n    if ($token == '') {\n        echo response(40001, false);\n    }\n    else {\n        $data = ['token' => $token];\n        echo response(0, $data);\n    }\n}\nelse {\n    echo response(30001, false);\n}\n")])])]),s("p",[a._v("剩下的无非是加密算法的不同，我最常用的是 md5，那么我们经过 md5 加密以后，其实还是不太安全，为什么呢？因为 md5 本身就不安全。虽然 md5 是不可逆的 hash 算法，反向算出来虽然困难，但是如果反向查询，密码设置的简单，也很容易被攻破。")]),a._v(" "),s("p",[a._v("比如我们使用 md5 加密一个密码 "),s("code",[a._v("123456")]),a._v("，对应的 md5 是 "),s("code",[a._v("e10adc3949ba59abbe56e057f20f883e")]),a._v("，找到一个 md5 解密的网站，比如 "),s("a",{attrs:{href:"http://cmd5.com/%EF%BC%8C%E5%BE%88%E5%AE%B9%E6%98%93%E5%B0%B1%E8%A2%AB%E7%A0%B4%E8%A7%A3%E4%BA%86%E5%AF%86%E7%A0%81%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%E5%91%A2%EF%BC%9F",target:"_blank",rel:"noopener noreferrer"}},[a._v("cmd5.com/，很容易就被破解了密码…"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"加盐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加盐"}},[a._v("#")]),a._v(" 加盐")]),a._v(" "),s("p",[a._v("工作一段时间的同学对这个名词应该不会陌生，这种方式算是给用户的隐私数据加上密了，其实就是一段隐私数据加一段乱码再进行 md5，用代码表示大致是这样：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 伪代码\nsalt = '#^&%**(^&(&*)_)_(*&^&#$%GVHKBJ(*^&*%^%&^&'\npassword = '123456'\npost_body = salt + password\nprint post_body.md5()\n// ffb34d898f6573a1cf14fdc34d3343c0\n")])])]),s("p",[a._v("现在，密码看起来挺靠谱的了，但是，我们知道加盐这种方式是比较早期的处理方式了，既然现在没有在大范围使用了，就说明单纯加盐还是存在缺陷的。")]),a._v(" "),s("h3",{attrs:{id:"有泄露的可能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有泄露的可能"}},[a._v("#")]),a._v(" 有泄露的可能")]),a._v(" "),s("p",[a._v("现在我们在客户端对密码做了 md5 加盐，服务器保存的也是加密后的内容，但是，盐是写在了客户端的源代码中，一旦对源代码进行反编译，找到 "),s("code",[a._v("salt")]),a._v(" 这个字符串，那么加盐的做法也就形同虚设了。")]),a._v(" "),s("p",[a._v("反编译源代码的代价也很高，一般对于安全性能要求不高的话，也够用了，但是，对于一些涉及资金之类的 App 来说，仅仅加盐还是不够的。")]),a._v(" "),s("p",[a._v("比如离职的技术同学不是很开心，又或者有人想花钱买这串字符等等，盐一旦被泄露，就是一场灾难，这也是盐最大的缺陷。")]),a._v(" "),s("h3",{attrs:{id:"依赖性太强"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖性太强"}},[a._v("#")]),a._v(" 依赖性太强")]),a._v(" "),s("p",[a._v("盐一旦被设定，那么再做修改的话就非常困难了，因为服务器存储的全部是加盐后的数据，如果换盐，那么这些数据全部都需要改动。"),s("strong",[a._v("但是可怕的不在于此，如果将服务器的数据改动后，旧版本的用户再访问又都不可以了，因为他们用的是之前的盐。")])]),a._v(" "),s("h2",{attrs:{id:"hmac"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hmac"}},[a._v("#")]),a._v(" HMAC")]),a._v(" "),s("p",[a._v("目前最常见的方式，应该就是 HMAC 了，HMAC 算法主要应用于身份验证，与加盐的不同点在于，盐被移到了服务器，服务器返回什么，就用什么作为盐。")]),a._v(" "),s("p",[a._v("这么做有什么好处呢？ 如果我们在登录的过程中，黑客截获了我们发送的数据，他也只能得到 HMAC 加密过后的结果，由于不知道密钥，根本不可能获取到用户密码，从而保证了安全性。")]),a._v(" "),s("p",[a._v("但是还有一个问题，前面我们讲到，"),s("strong",[a._v("盐被获取以后很危险，如果从服务器获取盐，也会被抓包，那还不如写在源代码里面呢，至少被反编译还困难点，那如果解决这个隐患呢")]),a._v("？")]),a._v(" "),s("p",[a._v("那就是，在用户注册时就生成和获取这个秘钥，以代码示例：")]),a._v(" "),s("p",[a._v("现在我们发送一个请求：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("GET http://localhost:8888/capsule/register.php?account=joy&password=789\n")])])]),s("p",[a._v("服务器收到请求后，做了下面的事情：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];  //123456\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*制作一个随机的盐*/\n$salt = salt();\n\n/*检查用户名是否存在*/\n$is_exist = $db->check_user_exist($account);\n\nif ($is_exist) {\n    echo response(10001, false);\n}\nelse {\n\n    /*将密码进行 hmac 加密*/\n    $password = str_hmac($password,  $salt);\n\n    /*检查用户名是否添加成功*/\n    $result = $db->add_user($account, $password);\n\n    if ($result) {\n        $data = ['salt'=>$salt];\n        echo response(0, $data);\n        //echo response(0, true);\n    }\n    else {\n        echo response(20001, false);\n    }\n}\n")])])]),s("p",[a._v("服务器现在保存的是：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("account: joy\npassword: 05575c24576\n")])])]),s("p",[a._v("客户端拿到的结果是：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('{\n  "rc": 0,\n  "data": {\n    "salt": "5633905fdc65b6c57be8698b1f0e884948c05d7f"\n  },\n  "errorInfo": ""\n}\n')])])]),s("p",[a._v("那么客户端接下来应该做什么呢？把 "),s("code",[a._v("salt")]),a._v(" 做本地的持久化，登录时将用户输入的密码做一次同样的 hmac，那么就能通过服务器的 "),s("code",[a._v("password: 05575c24576")]),a._v(" 校验了，发起登录请求：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("GET http://localhost:8888/capsule/login.php?account=joy&password=789\n// fail\nGET http://localhost:8888/capsule/login.php?account=joy&password=05575c24576\n// success\n")])])]),s("p",[a._v("现在我们解决了依赖性太强的问题，盐我们可以随意的更改，甚至可以是随机的，每个用户都不一样。这样单个用户的安全性虽然没有加强，但是整个平台的安全性缺大大提升了，很少有人会针对一个用户搞事情。但是细心的同学应该可以想到，现在的盐，也就是秘钥是保存在本地的，如果用户的秘钥丢失，比如换手机了，那么岂不是"),s("strong",[a._v("有正确的密码，也无法登陆了吗")]),a._v("？")]),a._v(" "),s("p",[a._v("针对这个问题，核心就是用户没有了秘钥，那么在用户登陆的时候，逻辑就需要变一下。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 伪代码\nfunc login(account, password) {\n    //如果有盐\n    if let salt = getSalt() {\n        //将密码进行 hmac，请求登陆接口\n        network.login(account, password.hmac(salt))\n    }\n    else {\n        //请求 getSalt 接口，请求参数为账户+应用标识\n        network.getSalt(account + bundleId, { salt in\n            //将盐保存在本地，再次调用自身。\n            savaSalt(salt)\n            login(account, password)\n        })\n    }\n}\n")])])]),s("p",[a._v("那么可想而知，我们的注册接口现在也需要新加一个 "),s("code",[a._v("bundleId")]),a._v(" 的请求参数，然后用 "),s("code",[a._v("account + bundleId")]),a._v(" 作为 key，来保存 "),s("code",[a._v("salt")]),a._v("：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$password = $_GET['password'];  //123456\n$bundle_id = $_GET['bundleId'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*制作一个随机的盐*/\n$salt = salt();\n\n/*检查用户名是否存在*/\n$is_exist = $db->check_user_exist($account);\n\nif ($is_exist) {\n    echo response(10001, false);\n}\nelse {\n    /*将密码进行 hmac 加密*/\n    $password = str_hmac($password,  $salt);\n\n    /*检查用户名是否添加成功*/\n    $result = $db->add_user($account, $password);\n\n    if ($result) {\n\n        /*检查秘钥是否保存成功*/\n        $save_salt = $db->save_salt($salt, $account, $bundle_id);\n\n        if ($save_salt) {\n            $data = ['salt'=>$salt];\n            echo response(0, $data);\n        }\n        else {\n            echo response(20001, false);\n        }\n    }\n    else {\n        echo response(20001, false);\n    }\n}\n")])])]),s("p",[a._v("同时我们需要创建一个获取 "),s("code",[a._v("salt")]),a._v(" 的接口：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("/*获取 get 请求传递的参数*/\n$account = $_GET['account'];\n$bundle_id = $_GET['bundleId'];\n\n/*创建数据连接*/\n$db = new DataBase();\n\n/*获取秘钥*/\n$salt = $db->get_salt($account, $bundle_id);\n\nif ($salt == '') {\n    echo response(40001, false);\n}\nelse {\n    $data = ['salt'=>$salt];\n    echo response(0, $data);\n}\n")])])]),s("p",[a._v("写到这里，就可以给大家介绍一个比较好玩的东西了。")]),a._v(" "),s("h3",{attrs:{id:"设备锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设备锁"}},[a._v("#")]),a._v(" 设备锁")]),a._v(" "),s("p",[a._v("一些 App 具有设备锁的功能，比如 QQ，这个功能是将账号与设备进行绑定，如果其他人知道了用户的账号和密码，但是设备不符，同样无法登录，怎样实现呢？")]),a._v(" "),s("p",[a._v("就是用户开启设备锁之后，如果设备中没有 "),s("code",[a._v("salt")]),a._v("，那么就不再请求 "),s("code",[a._v("getSalt")]),a._v(" 接口，而是转为其他验证方式，通过之后，才可以请求 "),s("code",[a._v("getSalt")]),a._v("。")]),a._v(" "),s("h3",{attrs:{id:"提升单个用户的安全性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#提升单个用户的安全性"}},[a._v("#")]),a._v(" 提升单个用户的安全性")]),a._v(" "),s("p",[a._v("现在这个 App 相对来说比较安全了，上面说到，因为每个用户的 "),s("code",[a._v("salt")]),a._v(" 都不一样，破解单个用户的利益不大，所以，对于平台来说安全性已经比较高了，但凡是都有例外，如果这个破坏者就是铁了心要搞事情，就针对一个用户，现在这个方案，还有哪些问题存在呢？")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("注册时返回的 "),s("code",[a._v("salt")]),a._v(" 被抓包时有可能会泄露；")])]),a._v(" "),s("li",[s("p",[a._v("更换设备后，获取的 "),s("code",[a._v("salt")]),a._v(" 被抓包时有可能会泄露；")])]),a._v(" "),s("li",[s("p",[a._v("保存在本地的 "),s("code",[a._v("salt")]),a._v(" ，有可能通过文件路径获取到；")])]),a._v(" "),s("li",[s("p",[a._v("抓包的人就算不知道密码，通过 hmac 加密后的字符，也可以进行登录；")]),a._v(" "),s("p",[a._v("怎么处理呢？首先我们需要清楚的是，之所以会被破解，是拿到了我们加密时的因子，或者叫种子，这个种子服务器和客户端都必须要有，如果没有的话，两者就无法进行通信了，但是我们也不能在客户端将种子写死，在服务器给客户端种子时，总会有可能被获取。")])])]),a._v(" "),s("p",[a._v("我们要设计一种思路，需要有一个种子，服务器和客户端之间无需通讯，但是都可以被理解的种子。")]),a._v(" "),s("p",[a._v("同时我们需要这个种子是动态的，每次加密的结果都不一样，那么就算抓到了加密后的密码，这个密码也随之失效了。")]),a._v(" "),s("p",[s("strong",[a._v("所以，我们需要一个无需服务器和客户端通讯的，动态的种子，时间。")])]),a._v(" "),s("h2",{attrs:{id:"hmac-时间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hmac-时间"}},[a._v("#")]),a._v(" HMAC+时间")]),a._v(" "),s("p",[a._v("这个动态的种子是如何使用的呢？")]),a._v(" "),s("ol",[s("li",[a._v("客户端发送注册请求，服务器返回 "),s("code",[a._v("salt")]),a._v("，保存 hmac 后的密码；")]),a._v(" "),s("li",[a._v("客户端保存 "),s("code",[a._v("salt")]),a._v("；")]),a._v(" "),s("li",[a._v("客户端发送登录请求，参数为 hmac 后的密码，加上当前的时间；")]),a._v(" "),s("li",[a._v("服务器收到登录请求，将数据库中的密码，加上当前的时间，进行比对；")])]),a._v(" "),s("p",[a._v("客户端代码：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 秘钥\nconst salt = ''\n// 当前时间，精确到分钟\nconst currentTime = '201709171204'\n// 用户输入的密码\nlet password = '123456'\n// (hmac+currentTime).md5\npassword = (password.hmac(salt) + currentTime).md5()\nnetwork('login', {method: 'GET', params: {password:password}})\n")])])]),s("p",[a._v("服务器代码：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function should_login($account, $password)\n{\n    $account = mysqli_real_escape_string($this->connection ,$account);\n    $password = mysqli_real_escape_string($this->connection, $password);\n    $user = $this->get_user($account);\n    if ($user == null) {\n        return false;\n    }\n    $password_local = $user['password'];\n    if ($password_local == '') {\n        return false;\n    }\n    $password_local = md5($password_local.current_time());\n    if ($password_local == $password) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n")])])]),s("p",[a._v("但是现在还有一点问题，那就是对时间的容错上，如果客户端发送的时候是 "),s("code",[a._v("201709171204")]),a._v("，服务器响应时却已经到了 "),s("code",[a._v("201709171205")]),a._v(" 了，那么这样势必是不能通过的，这种情况，只需要服务器把当前的时间减去一分钟，再校验一次，符合其中之一就可以。")]),a._v(" "),s("p",[a._v("聪明的你应该可以想到，这也就是"),s("strong",[a._v("验证码 5 分钟内有效期的实现")]),a._v("。")]),a._v(" "),s("p",[a._v("现在这个 App，就算注册时拿到了 "),s("code",[a._v("salt")]),a._v("，也很难在 1 分钟内反推出密码，同时，抓包的密码一分钟后也就失效了，对于单个用户的安全性，也有了进一步的提升。")])])}),[],!1,null,null,null);s.default=e.exports}}]);