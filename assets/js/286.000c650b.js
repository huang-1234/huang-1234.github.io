(window.webpackJsonp=window.webpackJsonp||[]).push([[286],{715:function(a,t,s){"use strict";s.r(t);var e=s(2),v=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"性能优化小册-异步堆栈追踪-为什么-await-胜过-promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能优化小册-异步堆栈追踪-为什么-await-胜过-promise"}},[a._v("#")]),a._v(" 性能优化小册 - 异步堆栈追踪：为什么 await 胜过 Promise")]),a._v(" "),t("p",[a._v("与直接使用 "),t("code",[a._v("Promise")]),a._v(" 相比，使用 "),t("code",[a._v("async/await")]),a._v(" 不仅可以使代码更具可读性，而且还可以在 JavaScript 引擎中实现一些有趣的优化。")]),a._v(" "),t("p",[a._v("这篇文章是关于一个这样的优化，涉及异步代码的堆栈追踪。")]),a._v(" "),t("p",[t("code",[a._v("async/await")]),a._v(" 和 "),t("code",[a._v("Promise")]),a._v(" 的根本区别在于 "),t("code",[a._v("await fn()")]),a._v(" 暂停当前函数的执行，而 "),t("code",[a._v("promise.then(fn)")]),a._v(" 在将 "),t("code",[a._v("fn")]),a._v(" 调用添加到回调链后，继续执行当前函数。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('const fn = () => console.log(\'hello\')\nconst a = async () => {\n  await fn() // 暂停 fn 的执行\n}\n// 调用 a 时，才恢复 fn 的执行\na() // "hello"\n\nconst promise = Promise.resolve()\n// 将 fn 添加到回调链后，继续执行 fn\npromise.then(fn) // "hello"\n')])])]),t("p",[a._v("在堆栈追踪的上下文中，这种差异非常显著。")]),a._v(" "),t("p",[a._v("当一个 "),t("code",[a._v("Promise")]),a._v(" 链（无论是否脱糖化）在任何时候抛出一个未经处理的异常时， JavaScript 引擎都会显示一条错误信息和（希望）记录一个有用的堆栈追踪。")]),a._v(" "),t("p",[a._v("作为一名开发人员，无论您使用的是普通的 "),t("code",[a._v("Promise")]),a._v(" 还是 "),t("code",[a._v("async await")]),a._v("，您都会期望这样。")]),a._v(" "),t("h2",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[a._v("#")]),a._v(" Promise")]),a._v(" "),t("p",[a._v("想象一个场景，当对异步函数 "),t("code",[a._v("b")]),a._v(" 的调用解析时，调用函数 "),t("code",[a._v("c")]),a._v("：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const b = () => Promise.resolve()\nconst a = () => {\n    b().then(() => c())\n}\n")])])]),t("p",[a._v("当调用 "),t("code",[a._v("a")]),a._v(" 时，将同步发生以下情况：")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("b")]),a._v(" 被调用并返回一个 "),t("code",[a._v("Promise")]),a._v("，该 "),t("code",[a._v("Promise")]),a._v(" 将在将来某个时刻解决。")]),a._v(" "),t("li",[t("code",[a._v(".then")]),a._v(" 回调（实际上是调用 "),t("code",[a._v("c()")]),a._v("）被添加到回调链中（ V8 术语中，[…]被添加为解析处理程序）。")])]),a._v(" "),t("p",[a._v("之后，我们完成了在函数 "),t("code",[a._v("a")]),a._v(" 的主体中执行代码。"),t("code",[a._v("a")]),a._v(" 永远不会被挂起，当对 "),t("code",[a._v("b")]),a._v(" 的异步调用解析时，上下文已经消失了。")]),a._v(" "),t("p",[a._v("想象一下如果 "),t("code",[a._v("b")]),a._v("（或 "),t("code",[a._v("c")]),a._v(" ）异步抛出异常会发生什么？理想情况下，堆栈追踪应该包括 "),t("code",[a._v("a")]),a._v("，因为 "),t("code",[a._v("b")]),a._v("（或 "),t("code",[a._v("c")]),a._v("）是从那里调用的，对吧？既然我们不在参考 "),t("code",[a._v("a")]),a._v(" 了 ，那怎样能做到呢？")]),a._v(" "),t("p",[a._v("为了让它工作，JavaScript 引擎需要在上面的步骤之外做一些事情："),t("strong",[a._v("它在有机会的时候捕获并存储堆栈追踪。")])]),a._v(" "),t("p",[a._v("在 "),t("strong",[a._v("V8")]),a._v(" 中，堆栈追踪附加到 "),t("code",[a._v("b")]),a._v(" 返回的 "),t("code",[a._v("Promise")]),a._v("。当 "),t("code",[a._v("Promise")]),a._v(" 实现时，堆栈追踪将被传递，以便 "),t("code",[a._v("c")]),a._v(" 可以根据需要使用它。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("b()[a] -> b().then()[a] -> c[a?:a]\n")])])]),t("p",[t("strong",[a._v("捕获堆栈追踪需要时间（即降低性能）；存储这些堆栈追踪需要内存。")])]),a._v(" "),t("h2",{attrs:{id:"async-await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[a._v("#")]),a._v(" async/await")]),a._v(" "),t("p",[a._v("下面是同样的程序，使用 "),t("code",[a._v("async/await")]),a._v(" 而不是 "),t("code",[a._v("Promise")]),a._v(" 编写：")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("b")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" Promise"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("resolve")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("a")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("async")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("await")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("b")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("c")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("使用 "),t("code",[a._v("await")]),a._v("，即使在 "),t("code",[a._v("await")]),a._v(" 调用中不收集堆栈追踪，我们也可以恢复调用链。")]),a._v(" "),t("p",[a._v("这是可能的，因为 "),t("code",[a._v("a")]),a._v(" 被挂起，正在等待 "),t("code",[a._v("b")]),a._v(" 解决。如果 "),t("code",[a._v("b")]),a._v(" 抛出异常，则可以按需以这种方式重建堆栈追踪。")]),a._v(" "),t("p",[a._v("如果 "),t("code",[a._v("c")]),a._v(" 抛出异常，堆栈追踪可以像同步函数那样构造，因为发生这种情况时，我们仍在 "),t("code",[a._v("a")]),a._v(" 上下文中。")]),a._v(" "),t("p",[a._v("通过遵循以下建议，使 JavaScript 引擎能够以更高效的方式处理堆栈追踪：")]),a._v(" "),t("ul",[t("li",[a._v("偏好 "),t("code",[a._v("async/await")]),a._v(" 胜过 "),t("code",[a._v("Promise")]),a._v("。")]),a._v(" "),t("li",[a._v("使用 "),t("a",{attrs:{href:"https://babeljs.io/docs/en/next/babel-preset-env.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("@babel/preset env"),t("OutboundLink")],1),a._v(" 避免不必要的 "),t("code",[a._v("async/await")]),a._v(" 传输。")])]),a._v(" "),t("p",[t("a",{attrs:{href:"https://mathiasbynens.be/notes/async-stack-traces",target:"_blank",rel:"noopener noreferrer"}},[a._v("英语原文"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);