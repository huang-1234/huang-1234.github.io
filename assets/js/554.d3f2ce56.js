(window.webpackJsonp=window.webpackJsonp||[]).push([[554],{991:function(s,t,a){"use strict";a.r(t);var v=a(2),_=Object(v.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h3",{attrs:{id:"常用git-stash命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用git-stash命令"}},[s._v("#")]),s._v(" 常用git stash命令：")]),s._v(" "),t("p",[s._v("（1）"),t("strong",[s._v("git stash")]),s._v(' save "save message" : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。')]),s._v(" "),t("p",[s._v("（2）"),t("strong",[s._v("git stash list")]),s._v(" ：查看stash了哪些存储")]),s._v(" "),t("p",[s._v("（3）"),t("strong",[s._v("git stash show")]),s._v(" ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}")]),s._v(" "),t("p",[s._v("（4）"),t("strong",[s._v("git stash show -p")]),s._v(" : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p")]),s._v(" "),t("p",[s._v("（5）"),t("strong",[s._v("git stash apply")]),s._v(" :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}")]),s._v(" "),t("p",[s._v("（6）"),t("strong",[s._v("git stash pop")]),s._v(" ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}")]),s._v(" "),t("p",[s._v("（7）"),t("strong",[s._v("git stash drop")]),s._v(" stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储")]),s._v(" "),t("p",[s._v("（8）"),t("strong",[s._v("git stash clear")]),s._v(" ：删除所有缓存的stash")]),s._v(" "),t("p",[t("strong",[s._v("说明:新增的文件，直接执行stash是不会被存储的")]),s._v("，举例如下：")]),s._v(" "),t("p",[s._v("如上图：在git status 那一步很明显可以看出来，我修改了README，添加了新文件abc.txt，然后执行了git stash save后，在执行git stash list 可以看到刚才的save是的信息，然后使用git stash show ，只显示了README的改动被存起来了。")]),s._v(" "),t("p",[s._v("我们知道，执行了git statsh 以后，被存起来的在当前目录再执行git status 就看不到了，但是我们现在再执行git status，如下：")]),s._v(" "),t("p",[s._v("a.txt")]),s._v(" "),t("p",[s._v("这个文件还在，说明没有被存起来。说白了就是没有在git 版本控制中的文件，是不能被git stash 存起来的。")]),s._v(" "),t("p",[s._v("那要怎么办呢，这个文件我也想存起来，很明显，先执行下git add 加到git版本控制中，然后再git stash就可以了，如下：")]),s._v(" "),t("p",[s._v("最后一步可以看出来，这个新增文件已经被stash了。")]),s._v(" "),t("p",[s._v("这个时候再执行下git status ,被存起来的在当前目录就看不到了,如下：")]),s._v(" "),t("p",[s._v("这个时候，想切分支就再也不会报错有改动未提交了。")]),s._v(" "),t("p",[s._v("如果要应用这些stash，直接使用git stash apply或者git stash pop就可以再次导出来了。")]),s._v(" "),t("p",[s._v("总结下：git add 只是把文件加到git 版本控制里，并不等于就被stash起来了，git add和git stash 没有必然的关系，但是执行git stash 能正确存储的前提是文件必须在git 版本控制中才行。")]),s._v(" "),t("p",[s._v("参考的一个链接中说到了以下，我摘录此处备份下（就是只stash一部分文件）：")]),s._v(" "),t("p",[s._v("常规 git stash 的一个限制是它会一下暂存所有的文件。有时，只备份某些文件更为方便，让另外一些与代码库保持一致。一个非常有用的技巧，用来备份部分文件：")]),s._v(" "),t("ol",[t("li",[s._v("add 那些你不想备份的文件（例如： git add file1.js, file2.js）")]),s._v(" "),t("li",[s._v("调用 git stash –keep-index。只会备份那些没有被add的文件。")]),s._v(" "),t("li",[s._v("调用 git reset 取消已经add的文件的备份，继续自己的工作。")])]),s._v(" "),t("p",[s._v("参考链接：")]),s._v(" "),t("p",[s._v("https://blog.csdn.net/jeffasd/article/details/53107182")]),s._v(" "),t("p",[s._v("http://www.cppblog.com/deercoder/archive/2011/11/13/160007.aspx")]),s._v(" "),t("p",[s._v("https://blog.csdn.net/baidu_21578557/article/details/52137324")]),s._v(" "),t("p",[s._v("https://blog.csdn.net/kingboyworld/article/details/76408819")]),s._v(" "),t("p",[s._v("https://blog.csdn.net/AndyNikolas/article/details/79906132")])])}),[],!1,null,null,null);t.default=_.exports}}]);