(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{458:function(t,s,a){"use strict";a.r(s);var n=a(2),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"回溯法解题框架"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯法解题框架"}},[t._v("#")]),t._v(" 回溯法解题框架")]),t._v(" "),s("p",[s("strong",[t._v("为防止失联, 请收藏三个镜像网站:")]),s("a",{attrs:{href:"https://labuladong.gitee.io/algo/",target:"_blank",rel:"noopener noreferrer"}},[s("strong",[t._v("Gitee pages")]),s("OutboundLink")],1),t._v("**(国内访问速度很快), "),s("strong",[s("a",{attrs:{href:"https://labuladong.gitbook.io/algo/",target:"_blank",rel:"noopener noreferrer"}},[s("strong",[t._v("Gitbook")]),s("OutboundLink")],1)]),t._v(", **"),s("a",{attrs:{href:"https://labuladong.github.io/algo/",target:"_blank",rel:"noopener noreferrer"}},[s("strong",[t._v("GitHub pages")]),s("OutboundLink")],1),t._v("~")]),t._v(" "),s("p",[t._v("相关推荐:")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:""}},[t._v("手把手带你刷二叉树(第二期)")])]),t._v(" "),s("li",[s("a",{attrs:{href:""}},[t._v("滑动窗口技巧")])])]),t._v(" "),s("p",[t._v("读完本文, 你不仅学会了算法套路, 还可以顺便去 LeetCode 上拿下如下题目:")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/permutations",target:"_blank",rel:"noopener noreferrer"}},[t._v("46. 全排列(中等)"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/n-queens",target:"_blank",rel:"noopener noreferrer"}},[t._v("51. N 皇后(困难)"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("本文有视频版:"),s("a",{attrs:{href:"https://www.bilibili.com/video/BV1P5411N7Xc",target:"_blank",rel:"noopener noreferrer"}},[t._v("回溯算法框架套路详解"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("这篇文章是很久之前的一篇 "),s("a",{attrs:{href:"https://mp.weixin.qq.com/s/trILKSiN9EoS58pXmvUtUQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("回溯算法详解"),s("OutboundLink")],1),t._v(" 的进阶版, 之前那篇不够清楚, 就不必看了, 看这篇就行. 把框架给你讲清楚, 你会发现回溯算法问题都是一个套路.")]),t._v(" "),s("p",[t._v("本文解决几个问题:")]),t._v(" "),s("p",[t._v("回溯算法是什么? 解决回溯算法相关的问题有什么技巧? 如何学习回溯算法? 回溯算法代码是否有规律可循?")]),t._v(" "),s("p",[t._v("其实回溯算法其实就是我们常说的 DFS 算法, 本质上就是一种暴力穷举算法.")]),t._v(" "),s("p",[t._v("废话不多说, 直接上回溯算法框架."),s("strong",[t._v("解决一个回溯问题, 实际上就是一个决策树的遍历过程")]),t._v(". 你只需要思考 3 个问题:")]),t._v(" "),s("p",[t._v("1、路径: 也就是已经做出的选择.")]),t._v(" "),s("p",[t._v("2、选择列表: 也就是你当前可以做的选择.")]),t._v(" "),s("p",[t._v("3、结束条件: 也就是到达决策树底层, 无法再做选择的条件.")]),t._v(" "),s("p",[t._v("如果你不理解这三个词语的解释, 没关系, 我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思, 现在你先留着印象.")]),t._v(" "),s("p",[t._v("代码方面, 回溯算法的框架:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("def "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("路径"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 选择列表"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" 满足结束条件"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("        result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("路径"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" 选择 in 选择列表"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("        做选择        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("路径"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 选择列表"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("        撤销选择\n")])])]),s("p",[s("strong",[t._v("其核心就是 for 循环里面的递归, 在递归调用之前「做选择」, 在递归调用之后「撤销选择」")]),t._v(", 特别简单.")]),t._v(" "),s("p",[t._v("什么叫做选择和撤销选择呢, 这个框架的底层原理是什么呢? 下面我们就通过「全排列」这个问题来解开之前的疑惑, 详细探究一下其中的奥妙!")]),t._v(" "),s("h1",{attrs:{id:"一、全排列问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、全排列问题"}},[t._v("#")]),t._v(" 一、全排列问题")]),t._v(" "),s("p",[t._v("我们在高中的时候就做过排列组合的数学题, 我们也知道 "),s("code",[t._v("n")]),t._v(" 个不重复的数, 全排列共有 n! 个.")]),t._v(" "),s("p",[t._v("PS:"),s("strong",[t._v("为了简单清晰起见, 我们这次讨论的全排列问题不包含重复的数字")]),t._v(".")]),t._v(" "),s("p",[t._v("那么我们当时是怎么穷举全排列的呢? 比方说给三个数 "),s("code",[t._v("[1, 2, 3]")]),t._v(" , 你肯定不会无规律地乱穷举, 一般是这样:")]),t._v(" "),s("p",[t._v("先固定第一位为 1, 然后第二位可以是 2, 那么第三位只能是 3; 然后可以把第二位变成 3, 第三位就只能是 2 了; 然后就只能变化第一位, 变成 2, 然后再穷举后两位……")]),t._v(" "),s("p",[t._v("其实这就是回溯算法, 我们高中无师自通就会用, 或者有的同学直接画出如下这棵回溯树:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fb847370747577e500942731dfbc3822c9e445e7b.jpg?alt=media",alt:"img"}})]),t._v(" "),s("p",[t._v("只要从根遍历这棵树, 记录路径上的数字, 其实就是所有的全排列."),s("strong",[t._v("我们不妨把这棵树称为回溯算法的「决策树」")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("为啥说这是决策树呢, 因为你在每个节点上其实都在做决策")]),t._v(". 比如说你站在下图的红色节点上:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F2bca8736780b65bbdff30a69fb8e23c7964a1485.jpg?alt=media",alt:"img"}})]),t._v(" "),s("p",[t._v("你现在就在做决策, 可以选择 1 那条树枝, 也可以选择 3 那条树枝. 为啥只能在 1 和 3 之中选择呢? 因为 2 这个树枝在你身后, 这个选择你之前做过了, 而全排列是不允许重复使用数字的.")]),t._v(" "),s("p",[s("strong",[t._v("现在可以解答开头的几个名词:**")]),t._v(" "),s("code",[t._v("[2]")]),t._v(" ** "),s("strong",[t._v("就是「路径」, 记录你已经做过的选择; **")]),t._v(" "),s("code",[t._v("[1, 3]")]),t._v(" ** "),s("strong",[t._v("就是「选择列表」, 表示你当前可以做出的选择; 「结束条件」就是遍历到树的底层, 在这里就是选择列表为空的时候")]),t._v(".")]),t._v(" "),s("p",[t._v("如果明白了这几个名词, "),s("strong",[t._v("可以把「路径」和「选择」列表作为决策树上每个节点的属性")]),t._v(", 比如下图列出了几个节点的属性:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fb016864ae8dd85f027f4bc983eb8871baa4e68a7.jpg?alt=media",alt:"img"}})]),t._v(" "),s("p",[s("strong",[t._v("我们定义的")]),t._v(" "),s("strong",[s("code",[t._v("backtrack")])]),t._v(" "),s("strong",[t._v("函数其实就像一个指针, 在这棵树上游走, 同时要正确维护每个节点的属性, 每当走到树的底层, 其「路径」就是一个全排列")]),t._v(".")]),t._v(" "),s("p",[t._v("再进一步, 如何遍历一棵树? 这个应该不难吧. 回忆一下之前 "),s("a",{attrs:{href:""}},[t._v("学习数据结构的框架思维")]),t._v(" 写过, 各种搜索问题其实都是树的遍历问题, 而多叉树的遍历框架就是这样:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("traverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("TreeNode root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("TreeNode child "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("childern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 前序遍历需要的操作")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("traverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("child"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 后序遍历需要的操作")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("而所谓的前序遍历和后序遍历, 他们只是两个很有用的时间点, 我给你画张图你就明白了:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F3690d9637ccf0f072e996376d50f5198a22fb36a.jpg?alt=media",alt:"img"}})]),t._v(" "),s("p",[s("strong",[t._v("前序遍历的代码在进入某一个节点之前的那个时间点执行, 后序遍历代码在离开某个节点之后的那个时间点执行")]),t._v(".")]),t._v(" "),s("p",[t._v("回想我们刚才说的, 「路径」和「选择」是每个节点的属性, 函数在树上游走要正确维护节点的属性, 那么就要在这两个特殊时间点搞点动作:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F727ed1ecd086bf28e5c0a22ddd20246839cd34ba.jpg?alt=media",alt:"img"}})]),t._v(" "),s("p",[t._v("现在, 你是否理解了回溯算法的这段核心框架?")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" 选择 in 选择列表"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    # 做选择\n    将该选择从选择列表移除\n    路径"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("选择"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("路径"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 选择列表"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    # 撤销选择\n    路径"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("remove")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("选择"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    将该选择再加入选择列表\n")])])]),s("p",[s("strong",[t._v("我们只要在递归之前做出选择, 在递归之后撤销刚才的选择")]),t._v(", 就能正确得到每个节点的选择列表和路径.")]),t._v(" "),s("p",[t._v("下面, 直接看全排列代码:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("List"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("List"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Integer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" res "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token generic-function"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("LinkedList")]),s("span",{pre:!0,attrs:{class:"token generic class-name"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 主函数，输入一组不重复的数字，返回它们的全排列 */")]),t._v("List"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("List"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Integer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("permute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" nums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 记录「路径」    LinkedList<Integer> track = new LinkedList<>();    backtrack(nums, track);    return res;}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 路径：记录在 track 中// 选择列表：nums 中不存在于 track 的那些元素// 结束条件：nums 中的元素全都在 track 中出现void backtrack(int[] nums, LinkedList<Integer> track) {    // 触发结束条件    if (track.size() == nums.length) {        res.add(new LinkedList(track));        return;    }")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" nums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 排除不合法的选择        if (track.contains(nums[i]))            continue;        // 做选择        track.add(nums[i]);        // 进入下一层决策树        backtrack(nums, track);        // 取消选择        track.removeLast();    }}")]),t._v("\n")])])]),s("p",[t._v("我们这里稍微做了些变通, 没有显式记录「选择列表」, 而是通过 "),s("code",[t._v("nums")]),t._v(" 和 "),s("code",[t._v("track")]),t._v(" 推导出当前的选择列表:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F368dee24bab62b1c27fd4a8387cea9619605195f.jpg?alt=media",alt:"img"}})]),t._v(" "),s("p",[t._v("至此, 我们就通过全排列问题详解了回溯算法的底层原理. 当然, 这个算法解决全排列不是很高效, 应为对链表使用 "),s("code",[t._v("contains")]),t._v(" 方法需要 O(N) 的时间复杂度. 有更好的方法通过交换元素达到目的, 但是难理解一些, 这里就不写了, 有兴趣可以自行搜索一下.")]),t._v(" "),s("p",[t._v("但是必须说明的是, 不管怎么优化, 都符合回溯框架, 而且时间复杂度都不可能低于 O(N!), 因为穷举整棵决策树是无法避免的."),s("strong",[t._v("这也是回溯算法的一个特点, 不像动态规划存在重叠子问题可以优化, 回溯算法就是纯暴力穷举, 复杂度一般都很高")]),t._v(".")]),t._v(" "),s("p",[t._v("明白了全排列问题, 就可以直接套回溯算法框架了, 下面简单看看 N 皇后问题.")]),t._v(" "),s("h1",{attrs:{id:"二、n-皇后问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、n-皇后问题"}},[t._v("#")]),t._v(" 二、N 皇后问题")]),t._v(" "),s("p",[t._v("这个问题很经典了, 简单解释一下: 给你一个 N×N 的棋盘, 让你放置 N 个皇后, 使得它们不能互相攻击.")]),t._v(" "),s("p",[t._v("PS: 皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位.")]),t._v(" "),s("p",[t._v("这个问题本质上跟全排列问题差不多, 决策树的每一层表示棋盘上的每一行; 每个节点可以做出的选择是, 在该行的任意一列放置一个皇后.")]),t._v(" "),s("p",[t._v("因为 C++ 代码对字符串的操作方便一些, 所以这道题我用 C++ 来写解法, 直接套用回溯算法框架:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("string"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 输入棋盘边长 n，返回所有合法的放置 */")]),t._v("\nvector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("string"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("solveNQueens")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// '.' 表示空，'Q' 表示皇后，初始化空棋盘。")]),t._v("\n      vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("string"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("board")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'.'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 路径：board 中小于 row 的那些行都已经成功放置了皇后")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 选择列表：第 row 行的所有列都是放置皇后的选择")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 结束条件：row 超过 board 的最后一行")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("string"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 触发结束条件")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                         "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" col "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" col "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" col"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 排除不合法选择")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isValid")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" col"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("continue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 做选择")]),t._v("\n      board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("col"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'Q'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 进入下一行决策")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 撤销选择")]),t._v("\n      board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("col"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'.'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这部分主要代码, 其实跟全排列问题差不多, "),s("code",[t._v("isValid")]),t._v(" 函数的实现也很简单:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 是否可以在 board[row][col] 放置皇后？ */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isValid")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("string"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" col"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 检查列是否有皇后互相冲突")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("col"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'Q'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 检查右上方是否有皇后互相冲突")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" col "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'Q'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 检查左上方是否有皇后互相冲突")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" col "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'Q'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("PS: 肯定有读者问, 按照 N 皇后问题的描述, 我们为什么不检查左下角, 右下角和下方的格子, 只检查了左上角, 右上角和上方的格子呢?")]),t._v(" "),s("p",[t._v("因为皇后是一行一行从上往下放的, 所以左下方, 右下方和正下方不用检查(还没放皇后); 因为一行只会放一个皇后, 所以每行不用检查. 也就是最后只用检查上面, 左上, 右上三个方向.")]),t._v(" "),s("p",[t._v("函数 "),s("code",[t._v("backtrack")]),t._v(" 依然像个在决策树上游走的指针, 通过 "),s("code",[t._v("row")]),t._v(" 和 "),s("code",[t._v("col")]),t._v(" 就可以表示函数遍历到的位置, 通过 "),s("code",[t._v("isValid")]),t._v(" 函数可以将不符合条件的情况剪枝:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fa146fd6b92466062b1081fa9d71a1030b49334f5.jpg?alt=media",alt:"img"}})]),t._v(" "),s("p",[t._v("如果直接给你这么一大段解法代码, 可能是懵逼的. 但是现在明白了回溯算法的框架套路, 还有啥难理解的呢? 无非是改改做选择的方式, 排除不合法选择的方式而已, 只要框架存于心, 你面对的只剩下小问题了.")]),t._v(" "),s("p",[t._v("当 "),s("code",[t._v("N = 8")]),t._v(" 时, 就是八皇后问题, 数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法, 但是我们的算法只需要一秒就可以算出来所有可能的结果.")]),t._v(" "),s("p",[t._v("不过真的不怪高斯. 这个问题的复杂度确实非常高, 看看我们的决策树, 虽然有 "),s("code",[t._v("isValid")]),t._v(" 函数剪枝, 但是最坏时间复杂度仍然是 O(N^(N+1)), 而且无法优化. 如果 "),s("code",[t._v("N = 10")]),t._v(" 的时候, 计算就已经很耗时了.")]),t._v(" "),s("p",[s("strong",[t._v("有的时候, 我们并不想得到所有合法的答案, 只想要一个答案, 怎么办呢")]),t._v("? 比如解数独的算法, 找所有解法复杂度太高, 只要找到一种解法就可以.")]),t._v(" "),s("p",[t._v("其实特别简单, 只要稍微修改一下回溯算法的代码即可:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 函数找到一个答案后就返回")]),t._v("\ntruebool "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("string"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 触发结束条件")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" col "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" col "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" col"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n    board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("col"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'Q'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        board"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("col"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'.'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这样修改后, 只要找到一个答案, for 循环的后续递归穷举都会被阻断. 也许你可以在 N 皇后问题的代码框架上, 稍加修改, 写一个解数独的算法?")]),t._v(" "),s("h1",{attrs:{id:"三、最后总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、最后总结"}},[t._v("#")]),t._v(" 三、最后总结")]),t._v(" "),s("p",[t._v("回溯算法就是个多叉树的遍历问题, 关键就是在前序遍历和后序遍历的位置做一些操作, 算法框架如下:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("def "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" 选择 in 选择列表"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n        做选择\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        撤销选择\n")])])]),s("p",[s("strong",[t._v("写")]),t._v(" "),s("strong",[s("code",[t._v("backtrack")])]),t._v(" "),s("strong",[t._v("函数时, 需要维护走过的「路径」和当前可以做的「选择列表」, 当触发「结束条件」时, 将「路径」记入结果集")]),t._v(".")]),t._v(" "),s("p",[t._v("其实想想看, 回溯算法和动态规划是不是有点像呢? 我们在动态规划系列文章中多次强调, 动态规划的三个需要明确的点就是「状态」「选择」和「base case」, 是不是就对应着走过的「路径」, 当前的「选择列表」和「结束条件」?")]),t._v(" "),s("p",[t._v("某种程度上说, 动态规划的暴力求解阶段就是回溯算法. 只是有的问题具有重叠子问题性质, 可以用 dp table 或者备忘录优化, 将递归树大幅剪枝,\n这就变成了动态规划. 而今天的两个问题, 都没有重叠子问题, 也就是回溯算法问题了, 复杂度非常高是不可避免的.")])])}),[],!1,null,null,null);s.default=r.exports}}]);